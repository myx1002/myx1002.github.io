<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>计算机网络知识点(三)：TCP和UDP（已迁移） | 鸡毛蒜皮事(●&#39;◡&#39;●)</title>

<link rel="shortcut icon" href="http://mofish.pily.life/favicon.ico?v=1689146956047">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="http://mofish.pily.life/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            鸡毛蒜皮事(●&#39;◡&#39;●)
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1689146956047"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    计算机网络知识点(三)：TCP和UDP（已迁移）
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-11-25 ·
                    </time>
                    
                        <a href="http://mofish.pily.life/tag/k6ND9yEKgx/" class="post-tags">
                            # 计算机网络
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>😵 面试重灾区呀！！<br>
👻 TCP三次握手和四次挥手、TCP、UDP协议的区别、TCP 协议如何保证可靠传输等等</p>
<!-- more -->
<h2 id="目录">目录</h2>
<ul>
<li><a href="#TCP">1. TCP</a>
<ul>
<li><a href="#TCP的报文格式">1.1 TCP的报文格式</a></li>
<li><a href="#TCP的三次握手流程">1.2 TCP的三次握手流程</a></li>
<li><a href="#TCP的四次挥手流程">1.3 TCP的四次挥手流程</a></li>
<li><a href="#相关问题">1.4 相关问题</a>
<ul>
<li><a href="#为什么TCP链接需要三次握手">问题1：为什么TCP链接需要三次握手，两次不可以么，为什么？</a></li>
<li><a href="#三次握手过程中可以携带数据吗">问题2：三次握手过程中可以携带数据吗？</a></li>
<li><a href="#什么是半连接队列">问题3：什么是半连接队列？</a></li>
<li><a href="#为什么断开连接是是四次挥手呢">问题4：为什么断开连接是是四次挥手呢？</a></li>
<li><a href="#四次挥手释放连接时，等待2MSL的意义">问题5：四次挥手释放连接时，等待2MSL的意义?</a></li>
<li><a href="#TCP 协议如何保证可靠传输">问题6：TCP 协议如何保证可靠传输？</a></li>
<li><a href="#TCP 的短连接和长链接是啥">问题7：TCP 的短连接和长链接是啥？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#UDP">2. UDP</a>
<ul>
<li><a href="#UDP的报文格式">2.1 UDP的报文格式</a></li>
</ul>
</li>
<li><a href="#TCP和UDP对比">3. TCP和UDP对比</a>
<ul>
<li><a href="#TCP和UDP主要区别">3.1 主要区别</a></li>
<li><a href="#数据流模式和数据报模式">3.2 为什么 TCP 叫数据流模式？ UDP 叫数据报模式？</a></li>
<li><a href="#TCP和UDP分别对应的常见应用层协议">3.3 TCP和UDP分别对应的常见应用层协议</a></li>
</ul>
</li>
</ul>
<h1 id="a-nametcp1-tcp传输控制协议a"><a name="TCP">1. TCP（传输控制协议）</a></h1>
<p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。</p>
<h2 id="a-nametcp的报文格式11-tcp的报文格式a"><a name="TCP的报文格式">1.1 TCP的报文格式</a></h2>
<figure data-type="image" tabindex="1"><img src="http://mofish.pily.life/post-images/1637895179395.jpg" alt="" loading="lazy"></figure>
<ul>
<li>
<p>源端口： 数据发送方的端口号</p>
</li>
<li>
<p>目标端口：数据接受方的端口号</p>
</li>
<li>
<p>序号（是TCP可靠传输的关键部分）：序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。</p>
</li>
<li>
<p>确认号（是TCP可靠传输的关键部分）：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</p>
</li>
<li>
<p>数据偏移：表示本报文数据段距离报文段有多远</p>
</li>
<li>
<p>保留：保留以后用的</p>
</li>
<li>
<p>紧急比特URG：当值为1时表示次报文段中有需要紧急处理。</p>
</li>
<li>
<p>确认比特ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置1。</p>
</li>
<li>
<p>推送PSH：为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</p>
</li>
<li>
<p>复位比特RST：值为1时表示TCP连接存在严重的错误，需要重新进行连接。</p>
</li>
<li>
<p>同步比特SYN：值为1表示这是一个连接请求或连接接受报文。</p>
</li>
<li>
<p>终止比特FIN：用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
<li>
<p>窗口字段：滑动窗口大小，用来告知发送端接收端的缓存大小，以此来控制发送端发送数据的速率，从而达到流量控制。</p>
</li>
<li>
<p>校验和：用来检验首部和数据两部分的正确性</p>
</li>
<li>
<p>紧急指针字段：只有当 URG 标志置 1 时紧急指针才有效，表示紧急数据最后一个字节的序号</p>
</li>
</ul>
<hr>
<h2 id="a-nametcp的三次握手流程12-tcp的三次握手流程a"><a name="TCP的三次握手流程">1.2 TCP的三次握手流程</a></h2>
<figure data-type="image" tabindex="2"><img src="http://mofish.pily.life/post-images/1637898974102.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>第一次握手：Client讲数据包的标志位SYN设为1，随机产生一个值seq=j，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li>
<p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li>
<p>第三次握手：Client收到确认后，检查ack是否为j+1，ACK是否为1，如果正确，则将标志位ACK设为1，ack为k+1，并将该数据包发送给Server。Server检查ack是否为k+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态。</p>
</li>
</ul>
<blockquote>
<p>完成三次握手后，Client和Server之间可以开始传输数据了。</p>
</blockquote>
<hr>
<h2 id="a-nametcp的四次挥手流程13-tcp的四次挥手流程a"><a name="TCP的四次挥手流程">1.3 TCP的四次挥手流程</a></h2>
<figure data-type="image" tabindex="3"><img src="http://mofish.pily.life/post-images/1637908887632.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>第一次挥手：Client向Server端发送断开 TCP 连接请求的 [FIN，ACK] 报文，在报文中随机生成一个序列号 SEQ=x，表示要断开 TCP 连接。</p>
</li>
<li>
<p>第二次挥手：当Server收到Client发来的断开请求后，回复发送ACK报文，表示已经收到断开请求。回复时，由于回复的是客户端发来的请求，所以在客户端请求序列号seq=m的基础上加 1，得到ack=m+1。</p>
</li>
<li>
<p>第三次挥手：Server在回复完后，不会马上断开连接，而是在断开前确认传输到Client的数据是否已经全部传输完毕。确认全部数据传输完毕后，向客户端发送[FIN, ACK]报文，随机生成一个序列号seq=n。由于还是对客户端发来的 TCP 断开请求序列号seq=m进行回复，因此ack依然为m+1。</p>
</li>
<li>
<p>第四次挥手：Client收到Server发来的FIN后，就知道可以关闭连接了，因此再次发送ACK报文，告诉Server端可以关闭了。</p>
</li>
</ul>
<blockquote>
<p>完成四次挥手后，Client在等待2MSL后，依然没有收到回复，则证明Server端已经关闭了，那么Client端也可以关闭连接了。</p>
</blockquote>
<hr>
<h2 id="a-name相关问题14-相关问题a"><a name="相关问题">1.4 相关问题</a></h2>
<h3 id="a-name为什么tcp链接需要三次握手问题1为什么tcp链接需要三次握手两次不可以么为什么a"><a name="为什么TCP链接需要三次握手">问题1：为什么TCP链接需要三次握手，两次不可以么，为什么？</a></h3>
<p>原因一：因为<code>只有三次握手</code>，才能确认<code>双方的接收和发送功能</code>都是<code>正常</code>的</p>
<blockquote>
<ul>
<li>第一次握手：Server端(Client发送正常，自己接收正常) ,  Client(我不知道啥情况)</li>
<li>第二次握手：Server端(Client发送正常，自己接收正常) ,  Client(自己发送和接收正常，Server发送和接收正常)</li>
<li>第三次握手：Server端(Client发送和接收正常，自己发送和接收正常) ,  Client(自己发送和接收正常，Server发送和接收正常)</li>
</ul>
</blockquote>
<p>原因二：<code>防止已失效的链接</code>请求报文突然又传送到了服务端</p>
<blockquote>
<p>如果此时<code>网络拥塞</code>Client发出的连接请求迟迟到达不了Server端，于是便发起<code>超时重发请求</code>，其实<code>上一个请求并未丢失</code>，而上一个请求因为<code>网络问题延误</code>连接释放后的某个时间点才到达Server<br>
这是Server<code>误以为</code>是Client发出的<code>新的请求</code>，于是发送确认包，同意连接，<br>
如果此时<code>采用两次握手</code>的话，那么Server<code>发送确认包后</code>就<code>建立连接</code>，进入<code>ESTABLISHED状态</code>了，但是其实Client此时并<code>未发出新的</code>建立连接请求，并且已经是<code>CLOSED状态</code>了，所以对于Server的确认包<code>不予理睬</code>，而Server却<code>一直在等待</code>Client的请求，这样Server就白白<code>浪费资源</code>了。</p>
</blockquote>
<h3 id="a-name三次握手过程中可以携带数据吗问题2-三次握手过程中可以携带数据吗a"><a name="三次握手过程中可以携带数据吗">问题2： 三次握手过程中可以携带数据吗？</a></h3>
<blockquote>
<p>其实<code>第三次握手</code>的时候是<code>可以携带</code>数据的，但是<code>其它</code>的时候<code>不行</code>.<br>
因为<code>第一次握手</code>的时候，根本<code>不知道Server端</code>的<code>接收和发送能力</code>，如果可以发送数据的话，很<code>容易造成</code>攻击者每次都在第一次握手时<code>发送大量数据</code>，不理睬Server端的接收和发送能力，<code>导致Server端</code>需要<code>消耗很大的资源</code>来处理这些报文<br>
但是<code>第三次握手</code>的时候，由于<code>Client端</code>已经处于<code>ESTABLISHED状态</code>，并且<code>确认</code>了<code>Server端</code>有数据<code>收发的能力</code>了，所以<code>携带数据</code>也是<code>可以</code>的。</p>
</blockquote>
<h3 id="a-name什么是半连接队列问题3什么是半连接队列a"><a name="什么是半连接队列">问题3：什么是半连接队列？</a></h3>
<blockquote>
<p>Server在第一次收到Client的SYN之后，就会<code>处理SYN_RCVD状态</code>，此时双方还<code>没完全建立连接</code>，服务器会把<code>此种状态下的连接请</code>求放在一个队列里，这个队列我们称之为<code>半连接队列</code>。<br>
除此之外，还有一个<code>全连接队列</code>，用于存放<code>已经完成三次握手的连接</code>，但是如果<code>队列满了</code>的话，有<code>可能</code>出现<code>丢包</code>现象。</p>
</blockquote>
<h3 id="a-name为什么断开连接是是四次挥手呢问题4为什么断开连接是是四次挥手呢a"><a name="为什么断开连接是是四次挥手呢">问题4：为什么断开连接是是四次挥手呢？</a></h3>
<blockquote>
<p>简单的来说，<code>四次挥手</code>是为了<code>断开连接时</code>，<code>确保数据</code>能够<code>完整传输</code>。</p>
</blockquote>
<ul>
<li>
<p><strong>第一次挥手</strong>时，Server收到FIN报文通知时，仅仅是明确了Client端没有数据再发送过来了；</p>
</li>
<li>
<p><strong>第二次挥手</strong>时，如果Server只挥手一次的，<code>不一定能够</code>一次性<code>携带完整的数据</code>给到Client，所以此时只能回复一个ACK给对方，表示已经收到，并进入CLOSE_WAIT等待关闭状态，但是<code>此时还不能关闭</code>，因为后续<code>可能还有数据</code>传输给Client；</p>
</li>
<li>
<p><strong>第三次挥手</strong>时，<code>数据传输完毕</code>了，发送FIN报文进入LAST_ACK状态，告诉Client可以关闭了，<code>如果</code>此时<code>只有三次挥手</code>的话就结束，Client<code>不返回一个ACK</code>给Server端的话，那么Server端就<code>不能马上关闭</code>，而是<code>一直在等待Client的应答</code>，浪费资源</p>
</li>
<li>
<p><strong>第四次挥手</strong>时，Client发送ACK应答，告诉Server可以关闭了，然后自己进入TIME_WAIT状态，接下来就是等2MSL后，就进入CLOSE状态了。</p>
</li>
</ul>
<h3 id="a-name四次挥手释放连接时等待2msl的意义问题5四次挥手释放连接时等待2msl的意义为什么需要time_waita"><a name="四次挥手释放连接时，等待2MSL的意义">问题5：四次挥手释放连接时，等待2MSL的意义（为什么需要TIME_WAIT）?</a></h3>
<blockquote>
<p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
</blockquote>
<p><code>MSL</code>是<code>TCP报文</code>的<code>最大生命周期</code>。</p>
<ul>
<li>
<p>为了<code>确保</code>客户端发送的<code>最后一个ACK报文</code>可以<code>到达服务器</code>。就算ACK丢失了，服务器收不到，会以为发送的FIN客户端没有收到，会再发一次。而客户端可以再2MSL这个时间内收到这个重传的报文，再次给出回应报文；</p>
</li>
<li>
<p>为了<code>防止</code>之前已经<code>失效的</code>连接请求报文<code>出现在新连接中</code>。在客户端发送完最后一个ACK后，在<code>2MSL的时间</code>内，就可以保证在<code>两个传输方向</code>上的<code>尚未接收到</code>或者<code>迟到</code>的报文段<code>从网络中消失</code>，这样<code>新的连接</code>就<code>不会</code>出现<code>旧</code>连接的<code>请求报文</code>。</p>
</li>
</ul>
<h3 id="a-nametcp-协议如何保证可靠传输问题6tcp-协议如何保证可靠传输a"><a name="TCP 协议如何保证可靠传输">问题6：TCP 协议如何保证可靠传输？</a></h3>
<h4 id="1校验和"><strong>1.校验和：</strong></h4>
<p>发送的数据包的二进制相加，进位补1，然后取反，<strong>目的是检测数据在传输过程中的任何变化</strong>。如果收到段的检验和<strong>有差错</strong>，TCP将<strong>丢弃</strong>这个报文段和<strong>不确认收到</strong>此报文段。<br>
<img src="http://mofish.pily.life/post-images/1637996484216.png" alt="" width="300" height="300" loading="lazy"></p>
<br>
<h4 id="2序列号确认应答累计确认seq"><strong>2.序列号+确认应答（累计确认+seq）</strong></h4>
<p><strong>序列号</strong>：TCP传输时将每个字节的数据都进行了<code>编号</code><br>
<strong>确认应答</strong>：TCP传输的过程中，每次<code>接收</code>方收到<code>数据后</code>，都会<code>对传输方</code>进行<code>确认应答</code>。也就是发送<code>ACK报文</code>。这个<code>ACK报文</code>当中<code>带有</code>对应的<code>确认序列号</code>，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<figure data-type="image" tabindex="4"><img src="http://mofish.pily.life/post-images/1637997146051.png" alt="" loading="lazy"></figure>
<blockquote>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
</blockquote>
<br>
<h4 id="3超时重传"><strong>3.超时重传</strong></h4>
<p>当TCP发出一个段后，它启动一个<code>定时器</code>，<code>等待目的端确认</code>收到这个报文段。如果不能及时收到一个确认，将<code>重发</code>这个报文段。</p>
<br>
<h4 id="4连接管理"><strong>4.连接管理</strong></h4>
<p>就是<code>三次握手</code>和<code>四次挥手</code>的过程。</p>
<br>
<h4 id="5流量控制"><strong>5.流量控制</strong></h4>
<p>接收端在接收到数据后，对其进行处理。如果发送端的<code>发送速度太快</code>，导致<code>接收端</code>的<code>接收缓冲区</code>被<code>填充满</code>了。此时如果发送端<code>仍旧发送</code>数据，那么接下来发送的数据可能都会<code>丢包</code>，继而发生一系列丢包的连锁反应，例如超时重传什么的。</p>
<p><strong>而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是</strong><code>流量控制</code>。</p>
<p>下面只考虑A向B发送数据，假设在连接建立时，B告诉A它的接收窗口rwnd=400（receiver window）<br>
<img src="http://mofish.pily.life/post-images/1637998798820.png" alt="" loading="lazy"></p>
<blockquote>
<p>如果接收到窗口大小的值为0，那么发送方停止发送数据，并定期向接收端发送窗口探测数据的，让接收端把窗口大小告诉发送端。</p>
</blockquote>
<br>
<h4 id="6拥塞控制"><strong>6.拥塞控制</strong></h4>
<p>在TCP传输过程中，如果网络出现堵塞或者一开始就发送大量的数据导致堵塞，那么就会产生大量的丢包，导致大量的超时重传，严重影响传输，因此当出现堵塞时，应当控制发送方的速率。</p>
<p>这一点和流量控制很像，但是出发点不同。流量控制时为了接收端能够来得及接收，而拥塞控制时为了降低整个网络的拥塞程度。</p>
<blockquote>
<p>TCP 主要通过四个算法来进行拥塞控制：<code>慢开始</code>、<code>拥塞避免</code>、<code>快重传</code>、<code>快恢复</code>。</p>
</blockquote>
<p><strong>慢开始算法原理</strong>：<br>
<img src="http://mofish.pily.life/post-images/1638000354447.png" alt="" loading="lazy"></p>
<blockquote>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：<strong>拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口</strong>。</p>
</blockquote>
<p>为了了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。<br>
<img src="http://mofish.pily.life/post-images/1638001350213.png" alt="" loading="lazy"></li>
</ul>
<p>当TCP连接进行初始化是，将拥塞窗口置为1（图中的窗口单位不再使用字节而使用报文段，并且慢开始门限的初始值设置为16个报文段，即ssthresh=16）</p>
<blockquote>
<p><strong>慢开始和拥塞避免</strong><br>
1.开始慢开始算法（指数增长），当cwnd=16时（图中点1）开始执行拥塞避免算法，呈线性增长；<br>
2.当拥塞窗口cwnd=24时（图中点2）出现超时，发送方判定为网络拥塞，于是调整门限值ssthresh=cwnd/2=12，同时设置拥塞窗口为1，再次进入慢开始阶段；<br>
3.重复步骤1，开始慢开始算法，发送方每收到一个ACK拥塞窗口值就增加，当cwnd=12时（图中点3），再次执行拥塞避免算法。</p>
</blockquote>
<blockquote>
<p><strong>快重传和快恢复</strong><br>
4.当cwnd=16时（图中点4）出现了一个新的情况，就是发送方连续收到3个对统一报文段的重复确认（3-ACK）。发送方执行快重传和快恢复算法；<br>
<img src="http://mofish.pily.life/post-images/1638001770228.png" alt="" width="300" height="300" loading="lazy"><br>
5.发送方知道只是丢失了个别的报文段，于是不启动慢开始，而是先进行快重传然后执行快恢复算法。发送方设置调整门限值ssthresh=cwnd/2=8, 同时拥塞窗口cwnd=ssthresh=8（点5），然后进行拥塞避免算法。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>快重传：收到3个同样的确认就立刻重传，不等到超时；</li>
<li>快恢复：cwnd不是从1重新开始。</li>
</ul>
</blockquote>
<h3 id="a-nametcp-的短连接和长链接是啥问题7tcp-的短连接和长链接是啥a"><a name="TCP 的短连接和长链接是啥">问题7：TCP 的短连接和长链接是啥？</a></h3>
<p><strong>TCP短连接</strong></p>
<blockquote>
<p>过程：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接<br>
简述：短连接一般只会在 client/server间传递一次请求操作，操作完成后就关闭连接<br>
优点：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>
</blockquote>
<p><strong>TCP长连接</strong></p>
<blockquote>
<p>建立连接——数据传输...（保持连接）...数据传输——关闭连接<br>
简述：client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。<code>目前主流的都是使用Http1.1协议，默认使用Tcp长连接。</code><br>
优点：可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。</p>
</blockquote>
<!-- more -->
<hr>
<h1 id="a-nameudp2-udp用户数据报协议a"><a name="UDP">2. UDP（用户数据报协议）</a></h1>
<p>UDP（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文。</p>
<h2 id="a-nameudp的报文格式21-udp的报文格式a"><a name="UDP的报文格式">2.1 UDP的报文格式</a></h2>
<figure data-type="image" tabindex="5"><img src="http://mofish.pily.life/post-images/1638003150413.png" alt="" loading="lazy"></figure>
<ul>
<li>源端口号和目的端口号如上和TCP的相同</li>
<li>UDP长度：UDP报文的字节长度（包括首部和数据）</li>
<li>UDP校验和: 检验UDP首部和数据部分的正确性</li>
</ul>
<!-- more -->
<hr>
<h1 id="a-nametcp和udp对比3-tcp和udp对比a"><a name="TCP和UDP对比">3. TCP和UDP对比</a></h1>
<table>
    <tr>
        <td>协议</td> 
        <td>优点</td> 
        <td>缺点</td> 
        <td>应用场景</td> 
   </tr>
    <tr>
         <td >TCP（传输控制协议）</td>
         <td >可靠，稳定TCP的可靠提现在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</td>
        <td >慢，效率低，占用系统资源高。TCP在传递数据之前，要先建连接，会消耗时间，在数据传递时，确认机制、重传机制、拥塞控制机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。</td>  
        <td>需要传输大量数据且对可靠性要求高的情况下使用TCP。</td>
    </tr>
    <tr>
        <td >UDP（用户数据报协议）</td>  
        <td >快，UDP是一个无状态的传输协议，所以它在传递数据时非常快。</td>  
        <td >不可靠，不稳定 因为UDP没有TCP那些可靠的机制，如果网络质量不好，就和容易丢包</td>  
        <td>对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP。</td>
    </tr>
</table>
<hr>
<h2 id="a-nametcp和udp主要区别31-主要区别a"><a name="TCP和UDP主要区别">3.1 主要区别</a></h2>
<ul>
<li>TCP是面向连接的，UDP是无连接的；</li>
<li>TCP提供可靠的服务，UDP尽最大努力交付。因此TCP传送的数据，无差错，不丢失，不重复，且按序到达；而UDP传送的数据是有小小偏差的；</li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</li>
<li>TCP是面向字节流的，UDP是面向报文的；</li>
<li>TCP的开销大于UDP，除了TCP(20字节)首部开销比UDP(8字节)大之外，TCP还有建立连接、握手挥手、流量控制、拥塞控制等；</li>
<li>TCP数据传输慢，UDP数据传输快</li>
</ul>
<hr>
<h2 id="a-name数据流模式和数据报模式32-为什么-tcp-叫数据流模式-udp-叫数据报模式a"><a name="数据流模式和数据报模式">3.2 为什么 TCP 叫数据流模式？ UDP 叫数据报模式？</a></h2>
<ul>
<li>所谓**“流模式”**，<strong>是指TCP发送端发送几次数据和接收端接收几次数据是没有必然联系的</strong>，比如通过TCP连接发送数据，发送方只调用一次 write，发送了100个字节，但是对方可以分10次接收完，每次10个字节，反之亦然。</li>
<li><strong>原因</strong>：这是因为TCP是面向连接的，一个socket中收到的数据都是由同一台主机发出的，且有序地到达，所以每次读取多少数据都可以。</li>
</ul>
<br>
<ul>
<li>所谓的**“数据宝模式”**，<strong>是指UDP发送端调用了几次write，接收端就必选用相同的次数read读完</strong>。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。</li>
<li><strong>原因</strong>：这个是因为UDP是无连接的，只要知道接收端的IP和端口，任何主机都可以向接收端发送数据。这时候如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。</li>
</ul>
<hr>
<h2 id="a-nametcp和udp分别对应的常见应用层协议33-tcp和udp分别对应的常见应用层协议a"><a name="TCP和UDP分别对应的常见应用层协议">3.3 TCP和UDP分别对应的常见应用层协议</a></h2>
<table>
    <tr>
        <td>运输层协议</td> 
        <td>应用层协议</td> 
        <td>应用</td> 
   </tr>
    <tr>
        <td rowspan="4">TCP</td>  
         <td >SMTP（简单邮件传输协议）</td>   
        <td >电子邮件</td>  
    </tr>
    <tr>
         <td >HTTP（超文本传输协议）</td>
        <td >万维网</td>  
    </tr>
    <tr>
        <td >TELENT（远程终端协议）</td>
        <td >远程终端登录</td>  
    </tr>
    <tr>
        <td >FTP（文件传输协议）</td> 
        <td >文件传送</td>
    </tr>
    <tr>
        <td rowspan="3">UDP</td>
        <td >DNS（域名系统）</td>  
        <td >名称转换</td>  
    </tr>
    <tr>
        <td >TFTP（简单文件传输协议）</td>
        <td >文件传送</td>  
    </tr>
    <tr>
        <td >SNMP（简单网络管理协议）</td>   
        <td >网络管理</td>    
    </tr>
</table>
                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="http://mofish.pily.life/post/redis_learning_18/" class="post-title gt-a-link">
                    Redis学习之路(十八)：集群之cluster
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">打工人！打工魂！我爱打工！</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/myx1002/myx1002.github.io" target="_blank">Moyuxing</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="http://mofish.pily.life/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
