<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>计算机网络知识点(六)：Cookie、Session、Token和Jwt（已迁移） | 鸡毛蒜皮事(●&#39;◡&#39;●)</title>

<link rel="shortcut icon" href="http://mofish.pily.life/favicon.ico?v=1689146956047">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="http://mofish.pily.life/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            鸡毛蒜皮事(●&#39;◡&#39;●)
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1689146956047"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    计算机网络知识点(六)：Cookie、Session、Token和Jwt（已迁移）
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-12-10 ·
                    </time>
                    
                        <a href="http://mofish.pily.life/tag/k6ND9yEKgx/" class="post-tags">
                            # 计算机网络
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>🤠 继续整理一些比较零散的知识点。</p>
<!-- more -->
<h2 id="目录">目录</h2>
<ul>
<li><a href="#1. Cookie">1. Cookie</a></li>
<li><a href="#2. Session">2. Session</a></li>
<li><a href="#3. Token">3. Token</a></li>
<li><a href="#4. Jwt">4. Jwt</a></li>
</ul>
<hr>
<!-- more -->
<h1 id="cookie和session">Cookie和Session</h1>
<p><code>会话跟踪</code>是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。<code>Cookie</code>通过在<code>客户端</code>记录信息确定用户身份，<code>Session</code>通过在<code>服务器端</code>记录信息确定用户身份。</p>
<figure data-type="image" tabindex="1"><img src="http://mofish.pily.life/post-images/1639815187998.png" alt="" loading="lazy"></figure>
<h2 id="a-name1-cookie1-cookiea"><a name="1. Cookie">1. Cookie</a></h2>
<h3 id="11-工作原理">1.1 工作原理</h3>
<p>由于Http是一种<code>无状态</code>的协议，服务器单从网络连接上无从知道客户身份，因此需要给客户端们颁发一个<code>通行证</code>，每人一个，无论谁访问都必须携带自己的通行证。</p>
<p>这样，服务器就能从通行证上确认客户身份了，这就是<code>Cookie的工作原理。</code></p>
<br>
<h3 id="12-使用方式">1.2 使用方式</h3>
<p>Cookie实际上是一小段文本信息。客户端请求服务器时，如果服务器需要记录该用户状态，就会使用<code>response</code>向客户端浏览器颁发一个Cookie。</p>
<p>客户端浏览器会把Cookie保存起来，当浏览器再次请求该网站时，就会把<code>Cookie</code>连同<code>请求的内容</code>一并提交给服务器。</p>
<p>服务器接收到Cookie后，以此来辨认用户状态，而且服务器还可以根据实际情况修改Cookie内容。</p>
<br>
<h3 id="13-特点">1.3 特点</h3>
<ul>
<li>部分浏览器的Cookie的数量有限制</li>
<li>Cookie的长度不能超过4k，否则会截断，而且每次请求都带Cookie的时候，无形的浪费的带宽</li>
<li>Cookie存储在浏览器立案</li>
<li>不可跨域</li>
<li>实现简单</li>
<li>存储时间灵活</li>
<li>安全性低，可能会被截取篡改（后面会讲到XSS和CSRF）</li>
<li>可被用户设置禁用</li>
</ul>
<br>
<h3 id="14-有效期">1.4 有效期</h3>
<p>Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。</p>
<ul>
<li>
<p>maxAge &gt; 0，则表示该Cookie会在maxAge秒之后自动失效，浏览器会将maxAge为正数的Cookie<code>持久化</code>，即写到对应的<code>Cookie文件</code>中。无论客户<code>关闭</code>了浏览器还是电脑，只要还在maxAge秒之前，登录网站时该Cookie<code>仍然有效</code>。</p>
</li>
<li>
<p>maxAge = 0，则表示删除该Cookie。Cookie机制<code>没有提供删除</code>Cookie的方法，因此通过设置该Cookie<code>即时失效</code>实现删除Cookie的效果。失效的Cookie会被浏览器从<code>Cookie文件</code>或者<code>内存中删除</code>。</p>
</li>
<li>
<p>maxAge &lt; 0，Cookie<code>默认</code>的maxAge值为–1，为<code>临时性</code>Cookie，<code>不会</code>被持久化，<code>不会</code>被写到Cookie文件中。因此<code>关闭</code>浏览器后，该Cookie就会<code>失效</code>。</p>
</li>
</ul>
<br>
<h3 id="15-cookie的secure属性和httponly属性">1.5 Cookie的Secure属性和HttpOnly属性</h3>
<p>基于安全的考虑，需要给Cookie加上<code>Secure</code>和<code>HttpOnly</code>属性，HttpOnly比较好理解，设置<code>HttpOnly=true</code>的Cookie<code>不能被js获取到</code>，无法用document.Cookie打出Cookie的内容。</p>
<p>Secure属性是说如果一个Cookie被设置了<code>Secure=true</code>，那么这个Cookie<code>只能用Https协议</code>发送给服务器，用Http协议是不发送的。</p>
<hr>
<!-- more -->
<h2 id="a-name2-session2-sessiona"><a name="2. Session">2. Session</a></h2>
<p>除了使用Cookie外，还可以使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一点，但是相应的也恩加了服务器的存储压力。</p>
<h3 id="21-工作原理">2.1 工作原理</h3>
<p>Session是另外一种记录客户状态的机制，客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要根据客户端传过来的<code>SessionId</code>从该Session中查找该客户的状态就可以了。</p>
<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。<strong>Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了</strong>。</p>
<br>
<h3 id="22-使用方式">2.2 使用方式</h3>
<p>Session对象是在客户端<code>第一次请求</code>服务器的时候使用<code>session_start()</code>创建，接下来就可以根据业务逻辑把需要的数据存在Session中，那么客户端在当前会话期间就可以很方便的获取到这些数据了。</p>
<br>
<h3 id="23-特点">2.3 特点</h3>
<ul>
<li>可存储任意类型、任意大小的数据</li>
<li>用于存储一次会话的多次请求的数据，存在服务端</li>
<li>需要借助Cookie实现，如果浏览器禁用了Cookie可使用URL重写方案解决</li>
</ul>
<br>
<h3 id="24-有效期">2.4 有效期</h3>
<ul>
<li>可设置，默认超时时间是1440秒，超过默认时间就自动删除</li>
<li>如果关闭浏览器，或退出登录时，会重新生成会话，即新的sessionID，因为即使旧的为过期也会获取不到</li>
</ul>
<blockquote>
<p>Cookie与Session的对比</p>
<ul>
<li>
<p>作用范围不同：Cookie 保存在客户端（浏览器），Session 保存在服务器端。</p>
</li>
<li>
<p>存储方式不用：Cookie只能存储简单的字段串，Session可以存储任意数据类型。</p>
</li>
<li>
<p>有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</p>
</li>
<li>
<p>安全性不同：Cookie是以明文的形式存放在客户端，容易遭到不法获取，可加密后存放或使用Https；Session的话，虽然也依赖Cookie，但是因为数据放在服务器端，所以相对安全一点点。</p>
</li>
<li>
<p>存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</p>
</li>
</ul>
</blockquote>
<hr>
<!-- more -->
<h1 id="a-name3-token3-tokena"><a name="3. Token">3. Token</a></h1>
<figure data-type="image" tabindex="2"><img src="http://mofish.pily.life/post-images/1639816782145.png" alt="" loading="lazy"></figure>
<h2 id="31-什么是token">3.1 什么是Token？</h2>
<p>Token的意思是“令牌”，是服务端生成的一串字符串，作为客户端后续请求的一个标识。</p>
<p>当用户第一次登陆后，服务器生成一个Token并将此Token颁发给客户端，客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里，之后客户端请求时带上这个颁发Token，</p>
<p>服务器端解析验证这个Token，验证成功后才能有权限获取和处理相关数据。</p>
<br>
<h2 id="32-token的生成方式">3.2 Token的生成方式</h2>
<ul>
<li>
<p>简单Token的组成：<br>
uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（服务器端签名）token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）；</p>
</li>
<li>
<p>Jwt：后面介绍</p>
</li>
</ul>
<h2 id="33-为什么要用token对比cookie和session">3.3 为什么要用Token（对比Cookie和Session）</h2>
<ul>
<li><strong>a. 减轻服务器端存储负担</strong></li>
</ul>
<blockquote>
<p>对于Session来说，服务端需要保存每个用户的Session，增加服务器端的开销。</p>
<p>而Token则无需担心，像Jwt，可通过解析Token来获取基本信息。</p>
</blockquote>
<ul>
<li><strong>b. 开发简单</strong></li>
</ul>
<blockquote>
<p>对于Session，在分布式场景下要考虑Session共享的问题，在浏览器Cookie禁用的情况要要考虑<br>
SessionId的传输问题，另一方面还需要考虑解决跨域资源共享的问题。</p>
<p>而Token的话，只需要给客户端颁发令牌，客户端把令牌存起来，每次访问向服务器端访问资源的时候带上这个令牌即可。</p>
</blockquote>
<ul>
<li><strong>c. 安全性较好，无需考虑CSRF（跨站请求伪造）</strong></li>
</ul>
<blockquote>
<p>因为不再依赖于Cookie，所以就不需要考虑对CSRF（跨站请求伪造）的防范。</p>
<p>CSRF攻击者之所以屡屡得手，是因为用户请求的验证信息都存在Cookie中。攻击者甚至不需要知道验证信息具体是什么直接就通过Cookie绕过了验证。</p>
<p>针对这点，我们只要不将验证信息存放在Cookie中即可。通常的做法是Http 请求中利用参数加入一个随机产生的 Token，并在服务器端建立一个拦截器来验证这个 Token，如果请求中没有Token或者Token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p>
</blockquote>
<ul>
<li><strong>d. 无需考虑CORS（跨域资源共享）</strong></li>
</ul>
<blockquote>
<p>Cookie是不允许垮域访问的，或者说需要比较繁琐的方案去实现，但是这一点对Token机制是不存在的，前提是传输的用户认证信息通过Http头传输，而不是通过Cookie传输。</p>
</blockquote>
<ul>
<li><strong>e. 无状态</strong></li>
</ul>
<blockquote>
<p>Token机制在服务端不需要存储，因为Token 自身包含了所有登录用户的信息，只需要在客户端的Cookie或本地介质存储Token即可。</p>
</blockquote>
<ul>
<li><strong>f. 适用接口跨平台</strong></li>
</ul>
<blockquote>
<p>当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p>
</blockquote>
<br>
总的来说：Token的验证机制比Session的验证机制更加灵活方便。
<br>
<h2 id="34-如何保证token安全性">3.4 如何保证token安全性</h2>
<ul>
<li>
<p>Token授权机制<br>
可把Token缓存起来，收到请求后进行Token校验，如果<strong>Token不存在</strong>则说明请求无效。</p>
</li>
<li>
<p>时间戳超时机制<br>
Token的过期时间避免过长，检验到Token过期后说明请求无效。<strong>时间戳超时机制是防御DOS攻击的有效手</strong>段。</p>
</li>
<li>
<p>签名机制<br>
将 Token 和 时间戳 加上其他请求参数再用MD5或SHA-1算法（可根据情况加点盐）加密，加密后的数据就是本次请求的签名sign，服务端接收到请求后以同样的算法得到签名，并跟当前的签名进行比对，如果不一样，说明参数被更改过，直接返回错误标识。<strong>签名机制保证了数据不会被篡改</strong>。</p>
</li>
<li>
<p>拒绝重复调用机制（非必须）<br>
其实就是记录Token的使用情况，如果再次使用就说明Token无效，请求失败。拒绝重复调用机制确保Token被别人截获了也无法使用（如抓取数据）。</p>
</li>
</ul>
<blockquote>
<p>安全保障总结：<br>
如果有人劫持了请求，并对请求中的参数进行了修改，签名就无法通过；<br>
如果有人使用已经劫持的URL进行DOS攻击和爬取数据，那么他也只能最多使用30s；<br>
如果签名算法都泄露了怎么办？可能性很小，因为这里的“盐”值只有我们自己知道。</p>
</blockquote>
<br>
<h2 id="35-如果解决token失效的问题">3.5 如果解决Token失效的问题</h2>
<h3 id="方案一">方案一</h3>
<p>服务端保存Token状态，用户每次访问时自动推迟Token的过期时间--与Session的过期策略类似，但是如果频发发起请求时，就需要频繁去刷新过期时间，这个代价也是挺大的。</p>
<h3 id="方案二">方案二</h3>
<p>使用Refresh Token，它可以避免频繁的读写操作。这种方案服务端不用每次都刷新Token的过期时间，只需要每次判断一下，如果过期了就告诉客户端，让客户端使用Refresh Token去重新申请Access Token即可。但是Refresh Token也过期了，就只能重新登录了。</p>
<h1 id="a-name4-jwt4-jwta"><a name="4. Jwt">4. Jwt</a></h1>
<p>Jwt即JSON Web Token，也是Token的一种，只不过对比于自己实现的Token，Jwt提供了一个很具体的标准，把Token用”.“点号分割为三段，分别为：头部header、信息载体playload、签名signature。</p>
<h2 id="header">header</h2>
<p>头部承担两部分信息：</p>
<ul>
<li>声明类型 jwt</li>
<li>加密算法 HMAC SHA256等</li>
</ul>
<pre><code class="language-jwt">{
    'typ': 'JWT',
    'alg': 'HS256'
}
</code></pre>
<p>将头部进行base64加密，构成了第一部分</p>
<h2 id="playload">playload</h2>
<p>信息载体就是存放有效信息的地方，包含三部分</p>
<ul>
<li>标准中注册的声明 (建议但不强制使用)</li>
</ul>
<blockquote>
<p>iss: jwt签发者<br>
sub: jwt所面向的用户<br>
aud: 接收jwt的一方<br>
exp: jwt的过期时间，这个过期时间必须要大于签发时间<br>
nbf: 定义在什么时间之前，该jwt都是不可用的.<br>
iat: jwt的签发时间<br>
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>
</blockquote>
<ul>
<li>
<p>公共的声明<br>
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p>
</li>
<li>
<p>私有的声明<br>
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
</li>
</ul>
<h2 id="signature">signature</h2>
<p>签名部分是对前两部分(头部playload，信息载体playload)的签名，防止数据篡改。</p>
<p>按下列步骤生成：<br>
1、先指定密钥(secret)<br>
2、把头部(header)和载荷(payload)信息分别base64转换<br>
3、使用头部(header)指定的算法加密<br>
最终，signature = HS256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret)</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="http://mofish.pily.life/post/network_learning_05/" class="post-title gt-a-link">
                    计算机网络知识点(五)：URI、URL、URN区别（已迁移）
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">打工人！打工魂！我爱打工！</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/myx1002/myx1002.github.io" target="_blank">Moyuxing</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="http://mofish.pily.life/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
