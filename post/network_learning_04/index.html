<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>计算机网络知识点(四)：Http和Https（已迁移） | 鸡毛蒜皮事(●&#39;◡&#39;●)</title>

<link rel="shortcut icon" href="http://mofish.pily.life/favicon.ico?v=1689146956047">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="http://mofish.pily.life/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            鸡毛蒜皮事(●&#39;◡&#39;●)
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1689146956047"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    计算机网络知识点(四)：Http和Https（已迁移）
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-12-01 ·
                    </time>
                    
                        <a href="http://mofish.pily.life/tag/k6ND9yEKgx/" class="post-tags">
                            # 计算机网络
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>😵 同样是面试重灾区呀！！<br>
👻 Http的报文格式，各个版本的特性，Https的工作原理等等</p>
<!-- more -->
<h2 id="目录">目录</h2>
<ul>
<li><a href="#1. Http">1. Http</a>
<ul>
<li><a href="#1.1 Http的请求和响应报文格式">1.1 Http的请求和响应报文格式</a></li>
<li><a href="#1.2 Http协议的特征">1.2 Http协议的特征</a></li>
<li><a href="#1.3 Http协议与TCP/IP协议的关系">1.3 Http协议与TCP/IP协议的关系</a></li>
<li><a href="#1.4 Http短连接和长连接">1.4 Http短连接和长连接</a></li>
<li><a href="#1.5 Http1.0、1.1和2.0协议版本的区别和特性">1.5 Http1.0、1.1和2.0协议版本的区别和特性</a></li>
<li><a href="#1.6 额外知识点1">1.6 Http2.0的服务端推送和WebSocket的区别（为什么Http2.0的服务端推送不能代替websocket？）</a></li>
</ul>
</li>
<li><a href="#2. Https">2. Https</a>
<ul>
<li><a href="#2.1 Https工作原理">2.1 Https工作原理</a></li>
<li><a href="#2.2 Https与三次握手">2.2 Https与三次握手</a></li>
<li><a href="#2.3 对称加密和非对称加密">2.3 对称加密和非对称加密</a></li>
<li><a href="#2.4 三个随机数的作用">2.4 三个随机数的作用</a></li>
<li><a href="#2.5 Http和Https的区别">2.5 Http和Https的区别</a></li>
</ul>
</li>
</ul>
<hr>
<!-- more -->
<h1 id="a-name1-http1-httpa"><a name="1. Http">1. Http</a></h1>
<blockquote>
<p>Http，简称为“超文本传输协议”，是客户端和服务器端之间数据传输的格式规范。</p>
</blockquote>
<h2 id="a-name11-http的报文格式11-http的报文格式a"><a name="1.1 Http的报文格式">1.1 Http的报文格式</a></h2>
<p>Http的报文有<code>请求报文</code>和<code>响应报文</code>两种，下面分开来学习一下。</p>
<h3 id="请求报文"><strong>请求报文</strong></h3>
<p>Http的请求报文由<code>请求行</code>、<code>请求头</code>、<code>空行</code>和<code>请求内容</code>4个部分组成：</p>
<figure data-type="image" tabindex="1"><img src="http://mofish.pily.life/post-images/1638352147829.png" alt="" loading="lazy"></figure>
<p><strong>请求行：</strong></p>
<ul>
<li>请求方法：GET、POST、PUT、DELETE、PATCH等；</li>
<li>URL：统一资源定位符<a name="URI、URL、URN区别">URI、URL、URN的区别</a></li>
<li>协议版本：1.0、1.1、2.0等</li>
</ul>
<p><strong>请求头：</strong><br>
请求头部为请求报文添加一些附件信息，由”键值对“组成，每行一对，键值之间用冒号分隔，常见的请求头有：</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>接收请求的服务器地址，可以是IP:端口号，也可以是域名</td>
</tr>
<tr>
<td>User-Agent</td>
<td>发送请求的应用程序名称</td>
</tr>
<tr>
<td>Accpet-Language</td>
<td>通知服务端可以发送的语言</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>通知服务端可以发送的数据压缩格式</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>通知服务端可以发送的编码格式</td>
</tr>
<tr>
<td>Cookie</td>
<td>发送Cookie信息</td>
</tr>
</tbody>
</table>
<p><strong>空行：</strong><br>
<code>请求头</code>的<code>最后</code>会<code>有一个空行</code>，表示<code>请求头部结束</code>，接下来为请求正文，这一行<code>非常重要</code>，必不可少！</p>
<p><strong>请求正文：</strong></p>
<ul>
<li>
<p>GET是没有请求正文的，请求数据以地址的形式表现在请求行，但是对请求长度有限制；</p>
</li>
<li>
<p>POST、PUT等部分请求方法才会有请求正文，请求参数封装在Http请求的body中，以名称/值的形式出现，对传送数据的大小没有限制。</p>
</li>
</ul>
<br>
<h3 id="响应报文"><strong>响应报文</strong></h3>
<p>Http的响应报文由<code>状态行</code>、<code>响应头</code>、<code>空行</code>和<code>响应内容</code>4个部分组成：</p>
<figure data-type="image" tabindex="2"><img src="http://mofish.pily.life/post-images/1638416373534.png" alt="" loading="lazy"></figure>
<p><strong>状态行：</strong></p>
<ul>
<li>协议版本：http/1.1、http/1.0、h2</li>
<li>状态码：1xx、2xx、3xx、4xx、5xx</li>
<li>状态码描述：状态码对应的描述，如OK、Forbidden、Internal Server Error等</li>
</ul>
<p><strong>响应头：</strong><br>
与请求头部类似，为响应报文添加了一些附加信息</p>
<table>
<thead>
<tr>
<th>响应头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Server</td>
<td>服务器应用程序软件的名称和版本，如nginx/1.19.0</td>
</tr>
<tr>
<td>Content-Type</td>
<td>响应正文的类型（是图片还是二进制字符串），如application/json</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应正文长度</td>
</tr>
<tr>
<td>Content-Charset</td>
<td>响应正文使用的编码</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>响应正文使用的数据压缩格式</td>
</tr>
</tbody>
</table>
<p><strong>空行：</strong><br>
<code>响应头</code>的<code>最后</code>会<code>有一个空行</code>，表示<code>响应头部结束</code>，接下来为响应正文，这一行<code>非常重要</code>，必不可少！</p>
<p><strong>响应内容：</strong><br>
服务端返回的数据。</p>
<br>
<!-- more -->
<h2 id="a-name12-http协议的特征12-http协议的特征a"><a name="1.2 Http协议的特征">1.2 Http协议的特征</a></h2>
<ol>
<li>
<p><code>支持客户/服务器模式</code></p>
</li>
<li>
<p><code>简单快速</code>，由于Http协议简单，使得Http服务器的程序规模小，因而通信速度很快</p>
</li>
<li>
<p><code>灵活</code>，Http允许传输任意类型的数据对象。</p>
</li>
<li>
<p><code>无连接</code>，每次请求一次，释放一次连接。</p>
</li>
</ol>
<blockquote>
<p>这里的无连接指的是<code>短链接</code>，表示每次连接只能处理一个请求，优点就是存在连接都是有用的连接，不需要额外的控制，实现简单，但是如果会在建立和关闭连接上浪费时间。<br>
对应的也会有<code>长链接</code>，当Http协议头部中字段<code>Connection：keep-alive</code>表示支持长链接，为了解决频繁建立和关闭链接而出现，<code>长链接</code>可以省去较多的tcp建立/关闭操作，减少资源浪费、节省请求时间，对于<code>频繁请求资源</code>的客户，较适用于<code>长链接</code></p>
</blockquote>
<ol start="5">
<li><code>无状态</code>，Http协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。</li>
</ol>
<blockquote>
<p>Http 是一个无状态协议，这意味着每个请求都是<code>独立的</code>，Keep-Alive 没能改变这个结果。<br>
缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>
于是，两种用于保持Http连接状态的技术就应运而生了，一个是<code>Cookie</code>，而另一个则是<code>Session</code>，后面再详讲。</p>
</blockquote>
<br>
<!-- more -->
<h2 id="a-name13-http协议与tcpip协议的关系13-http协议与tcpip协议的关系a"><a name="1.3 Http协议与TCP/IP协议的关系">1.3 Http协议与TCP/IP协议的关系</a></h2>
<p>Http协议是<code>应用层协议</code>，在TCP之上，可以说是基于TCP连接的，主要解决<code>如何包装数据</code>。</p>
<p>而TCP协议是<code>传输层协议</code>，IP协议是<code>网络层协议</code>。 IP协议主要解决<code>网络路由和寻址问题</code>，TCP协议主要解决如何在IP层之上<code>可靠地传递数据包</code>，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是<code>可靠的</code>、<code>面向连接的</code>。</p>
<br>
<!-- more -->
<h2 id="a-name14-http短连接和长连接14-http短连接和长连接a"><a name="1.4 Http短连接和长连接">1.4 Http短连接和长连接</a></h2>
<p>在<code>HTTP/1.0</code>中<code>默认使用短连接</code>。也就是说，客户端和服务器每进行一次Http操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个Http会话。</p>
<p>而从<code>HTTP/1.1</code>起，<code>默认使用长连接</code>，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<pre><code class="language-http">Connection:keep-alive
</code></pre>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<blockquote>
<p>Ps：HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
</blockquote>
<br>
<!-- more -->
<h2 id="a-name15-http10-11和20协议版本的区别和特性15-http10-11和20协议版本的区别和特性a"><a name="1.5 Http1.0、1.1和2.0协议版本的区别和特性">1.5 Http1.0、1.1和2.0协议版本的区别和特性</a></h2>
<h3 id="http10">Http1.0</h3>
<ul>
<li>简述：Http1.0是一种<code>无连接</code>、<code>无状态</code>的<code>应用层协议</code>，每个请求都会新创建一个tcp连接，<code>完成后关闭</code>，不跟踪不记录过去的请求。</li>
</ul>
<blockquote>
<p>(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
</blockquote>
<ul>
<li>
<p>缺点：</p>
<ul>
<li><code>资源浪费</code>，正因为频繁的创建/关闭连接，无法复用连接，造成了资源上很大的浪费；</li>
<li><code>队头阻塞</code>，在一个请求接收到响应之后才会接着发送下一个,这也造成了head of line blocking(队头阻塞)。</li>
</ul>
</li>
<li>
<p>解决方案：现在的浏览器为了解决这个问题,采用了一个页面可以建立多个tcp连接的方式来进行。</p>
</li>
</ul>
<hr>
<h3 id="http11">Http1.1</h3>
<ul>
<li>
<p>简述：继承了http1.0的特点,同时改善了http的一些问题</p>
</li>
<li>
<p>改进点：</p>
<ul>
<li>持久连接</li>
</ul>
<blockquote>
<p>Http1.1增加了一个<code>Connection</code>字段，通过设置<code>Keep-Alive</code>可以保持Http连接<code>不断开</code>，<code>避免</code>了每次客户端与服务器请求都要<code>重复</code>建立释放建立TCP连接，<code>提高</code>了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求。</p>
</blockquote>
<ul>
<li>管道机制</li>
</ul>
<blockquote>
<p>即在同一个Tcp连接里面，客户端可以<code>同时发送多个请求</code>，但是服务端必须按照客户端请求的<code>先后顺序</code>依次回送响应的结果，以保证客户端能够区分出每次请求的响应内容。</p>
</blockquote>
<ul>
<li>增加Host字段</li>
</ul>
<blockquote>
<p>在Http1.1中增加Host请求头字段后，Web浏览器可以使用主机头名来明确表示要访问服务器上的哪个Web站点，这才实现了在一台Web服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟Web站点。</p>
</blockquote>
<ul>
<li>断点续传</li>
</ul>
<blockquote>
<p>&lt;code&gt;RANGE:bytes&lt;/code&gt;是Http1.1新增内容，表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传。</p>
</blockquote>
<ul>
<li>其它</li>
</ul>
<blockquote>
<p>Http1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</p>
</blockquote>
</li>
<li>
<p>缺点：</p>
<ul>
<li>虽然允许复用Tcp连接，但是同一个Tcp连接中，所有的数据通信都是按顺序来的，如果有一个堵住的话，后面就会有许多请求排队等着。这将导致“队头堵塞”</li>
<li>避免方式：减少请求数、同时多开持久连接</li>
</ul>
</li>
</ul>
<hr>
<h3 id="http20">Http2.0</h3>
<ul>
<li>
<p>简述：相较于之前的版本，Http2.0在性能上带来了很大的提升。</p>
</li>
<li>
<p>改进点：</p>
<ul>
<li>二进制分帧（多路复用的实现基础）</li>
</ul>
<blockquote>
<p>Http2.0在应用层和传输层之间增加了一个二进制分帧层。<br>
Http1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。Http2.0 则是一个彻底的二进制协议，头信息header和数据体body都是二进制，并且统称为”帧”：头信息帧（header frame）和数据帧（data frame）。</p>
</blockquote>
<ul>
<li>多路复用</li>
</ul>
<blockquote>
<p>所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流,每个数据流都以消息的方式进行发送,这个发送可以使乱序的,然后在通过每个帧头部的流标识符进行组装,同时每个数据流都可以设置优先级,可见http2.0真正实现了并行发送数据。</p>
</blockquote>
<blockquote>
<p>在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
</blockquote>
<blockquote>
<p>优点：这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。</p>
</blockquote>
<ul>
<li>首部压缩</li>
</ul>
<blockquote>
<p>一方面，客户端与服务端约定头部数据的编码来讲头部进行压缩后发送，减少请求头容量；<br>
另一方面，对于相同头部，为了避免重复发送，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号即可。</p>
</blockquote>
<ul>
<li>服务端推送</li>
</ul>
<blockquote>
<p>Http2.0允许服务器未经请求，主动向客户端发送资源</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="a-name16-额外知识点116-http20的服务端推送和websocket的区别为什么http20的服务端推送不能代替websocketa"><a name="1.6 额外知识点1">1.6 Http2.0的服务端推送和WebSocket的区别（为什么Http2.0的服务端推送不能代替websocket？）</a></h2>
<p>Http协议和WebSocket协议都是应用层的协议，两者应用场景不一样。</p>
<p>Http2.0主要用来一问一答的方式交付信息，是对Html、Css等JS资源的传输方式进行了优化，并没有提供新的JS API，也不能用于实时传输消息，比如我在Http2.0中请求 a.html 服务端会自动把css和一些其他资源一并返回。</p>
<p>而WebSocket是基于Http1.1的协议，可以创建一条Tcp连接，具有双向传输等特性，而且具有JS API，客户端可使用如下来连接：</p>
<pre><code class="language-js">new WebSocket(&quot;ws://hostname/chattingrom/&quot;)
</code></pre>
<p>因此，如果需要实时传输消息，目前还是需要使用WebSocket。</p>
<hr>
<!-- more -->
<h1 id="a-name2-https2-httpsa"><a name="2. Https">2. Https</a></h1>
<p>Https是<code>基于安全套接字</code>的Http协议,也可以理解为是<code>Http+SSL/TLS(数字证书)</code>的组合，比 HTTP 协议<code>安全</code>，可<code>防止</code>数据在传输过程中不被<code>窃取</code>、<code>改变</code>，<code>确保数据的完整性</code>，虽然不是绝对的安全，但是它大幅增加了中间人攻击的成本。</p>
<p>Https协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h2 id="a-name21-https工作原理21-https工作原理a"><a name="2.1 Https工作原理">2.1 Https工作原理</a></h2>
<figure data-type="image" tabindex="3"><img src="http://mofish.pily.life/post-images/1638953528059.png" alt="" loading="lazy"></figure>
<h3 id="第一步证书验证">第一步：证书验证</h3>
<ul>
<li>
<p>客户端向服务器端发送Https请求，等待服务器确认；</p>
</li>
<li>
<p>服务器服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将<code>crt公钥</code>以证书的形式<code>发送给客户端</code>（服务器端存放crt私钥和crt公钥）；</p>
</li>
<li>
<p>客户端检<code>验证书</code>是否<code>合法</code>，如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行下一步。</p>
</li>
</ul>
<blockquote>
<p>合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 &quot;发行者的数字签名&quot;，服务器证书上的域名是否和服务器的实际域名相匹配。</p>
</blockquote>
<h3 id="第二步获取对称密钥">第二步：获取对称密钥</h3>
<ul>
<li>
<p>客户端生成一个随机值(对称密钥 Pre-master secret)，然后使用服务端发送过来的<code>公钥</code>对其进行<code>加密</code>，并发送给服务端；</p>
</li>
<li>
<p>服务端使用<code>crt私钥解密</code>，取出对称密钥，即得到了客户端的私钥，之后客户端和服务端就可以用过这个私钥进行通信了。</p>
</li>
</ul>
<h3 id="第三步传输加密数据">第三步：传输加密数据</h3>
<ul>
<li>
<p>之后服务器就用解密出来的对称密钥对返回数据进行加密后返回给客户端，客户端也使用该对称密钥对内容进行解密；</p>
</li>
<li>
<p>发送请求时也是，客户端对请求内容进行加密，服务端同样使用密钥对该请求进行解密后再进行业务处理。</p>
</li>
</ul>
<hr>
<h2 id="a-name22-https与三次握手22-https与三次握手a"><a name="2.2 Https与三次握手">2.2 Https与三次握手</a></h2>
<p>三次握手是属性传输层的概念，Https通常是SSL+Http的简称，目前使用的Https/Http协议都是<code>基于Tcp协议之上</code>的，因此也需要三次握手。</p>
<p>但是<code>Tcp</code>的三次握手建立连接<code>之后</code>，才会进行SSL握手的过程（即<code>身份认证</code>和<code>密钥协商</code>的过程）。</p>
<blockquote>
<p>三次握手是确保建立连接，双方准备好通信<br>
SSL的目的是加密通信的上次数据</p>
</blockquote>
<hr>
<h2 id="a-name23-对称加密和非对称加密23-对称加密和非对称加密a"><a name="2.3 对称加密和非对称加密">2.3 对称加密和非对称加密</a></h2>
<ul>
<li>
<p>对称加密：加密和解密时使用的密钥是<code>一样的</code>，我们将其称为堆成加密。例如上面提到的对称密钥（客户钥）</p>
</li>
<li>
<p>非对称加密：加密的密钥 e 和解密的密钥 d 是<code>不同的</code>（即 e != d），并且加密的密钥 e 是公开的，叫做公钥，而解密的密钥 d 是保密的，叫私钥。例如上面提到的的 crt 公钥和 crt 私钥。</p>
</li>
</ul>
<blockquote>
<p>Https在<code>内容传输</code>的加密上使用的是<code>对称加密</code>，<code>非对称加密</code>只作用于<code>证书验证</code>阶段，<br>
因为<code>非对称加密</code>的加解密<code>效率</code>非常<code>低</code>，而Http的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。</p>
</blockquote>
<hr>
<h2 id="a-name24-三个随机数的作用24-三个随机数的作用a"><a name="2.4 三个随机数的作用">2.4 三个随机数的作用</a></h2>
<ul>
<li>
<ol>
<li>客户端发送Https请求的时候，会随便生成一个随机数A发送给服务端</li>
</ol>
</li>
<li>
<ol start="2">
<li>服务端返回crt公钥的时候，也会生成一个随机数B，一并返回给客户端</li>
</ol>
</li>
<li>
<ol start="3">
<li>客户端收到crt公钥后，会生成一个随机密钥C(pre-master secret)，然后发送给服务端</li>
</ol>
</li>
</ul>
<p><strong>对于客户端：</strong><br>
当其生成了Pre-master secret之后，会结合原来的A、B随机数，用DH算法计算出一个master secret，紧接着根据这个master secret推导出hash secret和session secret。</p>
<p><strong>对于服务端：</strong><br>
当其解密获得了Pre-master secret之后，会结合原来的A、B随机数，用DH算法计算出一个master secret，紧接着根据这个master secret推导出hash secret和session secret。</p>
<blockquote>
<p>在客户端和服务端的master secret是依据三个随机数推导出来的，它是不会在网络上传输的，只有双方知道，不会有第三者知道。同时，客户端推导出来的session secret和hash secret与服务端也是完全一样的。</p>
<p>由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master secret本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>客户端和服务器加上pre-master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是1。</p>
</blockquote>
<hr>
<h2 id="a-name25-http和https的区别25-http和https的区别a"><a name="2.5 Http和Https的区别">2.5 Http和Https的区别</a></h2>
<ul>
<li>
<p>Http 以http:// 开头，而 Https 以 https:// 开头</p>
</li>
<li>
<p>Https 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书</p>
</li>
<li>
<p>Http 标准端口是 80 ，而 Https 的标准端口是 443</p>
</li>
<li>
<p>Http 是超文本传输协议，信息是明文传输，Https 则是具有安全性的 SSL 加密传输协议。</p>
</li>
<li>
<p>在 OSI 网络模型中，Https 的加密是在传输层完成的,因为 SSL 是位于传输层的</p>
</li>
</ul>
<hr>
<blockquote>
<p>知识点参考<br>
https://blog.csdn.net/Regino/article/details/105509254<br>
https://www.cnblogs.com/aidixie/p/11764181.html<br>
https://blog.csdn.net/qq_38289815/article/details/80969419<br>
https://blog.csdn.net/qq_31442743/article/details/116199453<br>
https://www.zhihu.com/question/32039008</p>
</blockquote>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="http://mofish.pily.life/post/network_learning_03/" class="post-title gt-a-link">
                    计算机网络知识点(三)：TCP和UDP（已迁移）
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">打工人！打工魂！我爱打工！</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/myx1002/myx1002.github.io" target="_blank">Moyuxing</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="http://mofish.pily.life/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
